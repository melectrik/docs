Cache
--------


ViUR provides an built-in caching-mechanism allowing to cache the whole result of requests. This means, its possible to have
the generated html stored in that cache and further requests to that url served completely from that cache.
Unfortunately, its impossible to determine candidates for caching in advance, so its up to the developer to enable caching on them.
To enable caching on a function, decorate that function with :py:func:`enableCache` from server.cache.

::

 from server.cache import *
 (..)

    @enableCache( urls=["/page/view", "/xml/page/view"],
                  userSensitive=False,
                  languageSensitive=True,
                  evaluatedArgs=["id"],
                  maxCacheTime=60*60*24 )
    def view( self, id, *args, **kwargs ):
  (...)


This decorator takes several arguments, specifying how caching should happen.

 - urls: A list of urls for the decorated function, for which the caching should happen. As a function
    can be reachable under several different urls (f.e. with different renders), its required to list the
    urls which should be cached. In the example above, caching is enabled for the default render (usually jinja2)
    and the xml-render. Its \emph{not} enabled for other renders (like the admin-interface ``/admin/page/view'').
    .. WARNING:: Never enable caching the admin! It will break things!
 - userSensitive: If true, signals that the result of the decorated function depends on the currently logged-in user.
    If False, the result is cached once and served to everyone, regardless if its a guest session or a known user.
 - languageSensitive: If true, signals that the result of the decorated function might got translated. If True,
    one result for each language will be cached and served. If False, it will serve the same cached content, regardless
    of the language set for the current session.
 - evaluatedArgs: List of keyword-arguments having influence to the output generated by
    that function. This list \emph{must} be complete! Parameters not named here are ignored!
    \emph{Warning:} Double-check this list! If f.e. the wrapped function generates a list of entries and
    you miss the parameter ``order'' here, it would be impossible to sort the list.
    It would always have the ordering it had when the cache-entry was created.
 - maxCacheTime: Specifies the maximum time an entry stays in the cache (in seconds).
    If None, the cache stay's valid forever (until manually erased by calling flushCache).
    .. NOTE::
        It's not erased from the db after that time, but it won't be served anymore.


With this cache implementation, its possible to cache the result of arbitrary functions. They can be just called internally
(through note they must return a string) or exposed on the http-layer. But they *must not* depend or modify global variables.
If they depend on reading external / global variables, the cache is not able to detect changes in these variables, and will continue
to serve content generated from a request with a different global variables set. Also, its not able to detect changes made on the environment
by its wrapped function. If your application relies on changes made to these global variables by the wrapped function, don't use the cache; it won't
reply such changes. The only exception is setting the content-type header. If your function sets that header to indicate it will serve a non-html
content, the cache will indicate that content-type if it serves a cached result.


server.cache - A Request Cache
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.. automodule:: server.cache
   :members:
   :undoc-members:
   :private-members:
   :special-members:
   :inherited-members:

