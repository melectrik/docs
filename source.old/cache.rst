Cache
--------


ViUR provides an built-in caching-mechanism allowing to cache the entire result of requests. This means, its possible to have
the generated html stored in that cache and further requests to that url served completely from that cache.
Unfortunately, its impossible to determine candidates for caching in advance, so its up to the developer to enable caching on them.
To enable caching on a function, decorate that function with :py:func:`enableCache` from server.cache.

::

 from server.cache import *
 (..)

    @enableCache( urls=["/page/view", "/xml/page/view"],
                  userSensitive=False,
                  languageSensitive=True,
                  evaluatedArgs=["id"],
                  maxCacheTime=60*60*24 )
    def view( self, id, *args, **kwargs ):
  (...)


This decorator takes several arguments, specifying how caching should happen.

 - urls: A list of urls for the decorated function, for which the caching should happen. As a function
    can be reachable under several different urls (f.e. with different renders), its required to list the
    urls which should be cached. In the example above, caching is enabled for the default render (usually jinja2)
    and the xml-render. Its *not* enabled for other renders (like the admin-interface ``/admin/page/view'').

    .. WARNING::

        Never enable caching for /admin and /vi! It will break things!
 - userSensitive: Define if (and how) the result of this functions depends on the user that's currently logged in.
        - 0 means independent of wherever the user is a guest or known, all will get the same content.
        - 1 means cache only for guests, no cache will be performed if the user is logged-in.
        - 2 means cache in two groups, one for guests and one for all users
        - 3 will cache the result of that function for each individual users separately.
 - languageSensitive: If true, signals that the result of the decorated function might got translated, so
        one result for each language will be cached and served. If False, it will serve the same cached content, regardless
        of the language set for the current session.
 - evaluatedArgs: List of keyword-arguments having influence to the output generated by
        that function. This list *must* be complete! Parameters not named here are ignored!

    .. WARNING::
        Double-check this list! If f.e. the wrapped function generates a list of entries and
        you miss the parameter *order* here, it would be impossible to sort the list.
        It would always have the ordering it had when the cache-entry was created.

 - maxCacheTime: Specifies the maximum time an entry stays in the cache (in seconds).
        If None, the cache stay's valid forever (until manually erased by calling flushCache).

    .. NOTE::
        It's not erased from the db after that time, but it won't be served anymore.


With this cache implementation, its possible to cache the result of arbitrary functions. They can be just called internally
(through note they must return a string) or exposed on the http-layer. But they *must not* depend on or modify global variables.
If they depend on reading external / global variables, the cache is not able to detect changes in these variables, and will continue
to serve content generated from a request with a different global variables set. Also, its not able to detect changes made on the environment
by its wrapped function. If your application relies on changes made to these global variables by the wrapped function, don't use the cache; it won't
reply such changes. The only exception is setting the content-type header. If your function sets that header to indicate it will serve a non-html
content, the cache will indicate that content-type if it serves a cached result.


server.cache - A Request Cache
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.. automodule:: server.cache
   :members:
   :undoc-members:
   :private-members:
   :special-members:
   :inherited-members:

